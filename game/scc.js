'use strict';var a,e,k=[],p={x:0,y:0,z:0,b:0,a:0,c:0},u=Function(),w={j:{},i:{},h:{},m:{},u:{},o:{},l:{},g:{},s:{}};function x(){var b=document.getElementById("c");b.requestPointerLock=b.requestPointerLock;document.exitPointerLock=document.exitPointerLock;document.addEventListener("mousemove",y,!1);document.addEventListener("pointerlockchange",z,!1);document.onkeydown=A;document.onkeyup=B}
function z(){document.pointerLockElement===document.getElementById("c")?document.addEventListener("mousemove",C,!1):document.removeEventListener("mousemove",C,!1)}function y(){document.getElementById("c").getBoundingClientRect()}function C(b){p.a-=b.movementX/140;p.b-=b.movementY/140}function A(){}function B(){}
function D(){a.clearColor(.5,.5,.5,1);a.clearDepth(1);a.enable(2929);a.depthFunc(515);a.clear(16640);u();k.forEach(function(b){var f=Math.tan(.5*Math.PI-.3927),d=1/-99.9;f=new Float32Array([f/(a.canvas.clientWidth/a.canvas.clientHeight),0,0,0,0,f,0,0,0,0,100.1*d,-1,0,0,20*d,0]);d=[p.x,p.y,p.z];var g=p.b,h=p.a,c=Math.cos(g);g=Math.sin(g);var m=Math.cos(h),n=Math.sin(h);h=[m,0,-n];var l=[n*g,c,m*g];c=[n*c,-g,c*m];d=new Float32Array([h[0],l[0],c[0],0,h[1],l[1],c[1],0,h[2],l[2],c[2],0,-E(h,d),-E(l,d),
-E(c,d),1]);c=b.f;if(!Array.isArray(b.f)){c=b.f;g=Math.cos(c.b);m=Math.sin(c.b);h=Math.cos(c.a);l=Math.sin(c.a);n=Math.cos(c.c);var q=Math.sin(c.c),v=c.d,r=c.e,t=c.w;c=[h*v*n,h*q*v,-l*v,0,-g*q*r+m*l*r*n,g*r*n+m*l*q*r,m*h*r,0,g*l*t*n+m*q*t,g*l*q*t-m*t*n,g*h*t,0,c.x,c.y,c.z,1]}c=new Float32Array(c);F(w.j,b.D,3);F(w.i,b.C,3);F(w.h,b.v,4);a.bindBuffer(34963,b.B);a.useProgram(e);a.uniformMatrix4fv(w.o,!1,f);a.uniformMatrix4fv(w.u,!1,d);a.uniformMatrix4fv(w.m,!1,c);a.uniform3f(w.g,p.x,p.y,p.z);a.uniform3f(w.l,
50,50,50);a.uniform1i(w.s,void 0===b.F);a.drawElements(4,b.A,5125,0)});requestAnimationFrame(D)}function F(b,f,d){a.bindBuffer(34962,f);a.vertexAttribPointer(b,d,5126,!1,0,0);a.enableVertexAttribArray(b)}function G(b,f){b=a.createShader(b);a.shaderSource(b,f);a.compileShader(b);console.log("Shader compiled successfully: "+a.getShaderParameter(b,35713));console.log("Shader compiler log: "+a.getShaderInfoLog(b));return b}function E(b,f){return b[0]*f[0]+b[1]*f[1]+b[2]*f[2]};(function(){a=document.getElementById("c").getContext("webgl2");var b=G(35633,"\nattribute vec3 in_position;\nattribute vec3 in_normal;\nattribute vec4 in_color;\n\nuniform mat4 model_matrix, view_matrix, projection_matrix;\n\nvarying highp vec3 world_pos;\nvarying highp vec3 world_normal;\nvarying highp vec4 world_color;\nvarying highp vec4 viewSpace;\nbool useShading;\n    \nvoid main() {\n    world_pos = (model_matrix * vec4(in_position,1)).xyz;\n    world_normal = normalize(mat3(model_matrix) * in_normal);\n    world_color = in_color;\n\n    viewSpace = view_matrix * model_matrix * vec4(in_position,1);\n    gl_Position = projection_matrix * viewSpace;\n}"),
f=G(35632,"\nuniform highp vec3 light_position;\nuniform highp vec3 eye_position;\nuniform bool useShading;\n \n//can pass them as uniforms\nconst highp vec3 DiffuseLight = vec3(0.1, 0.1, 0.1);\n//const highp vec3 RimColor = vec3(0.);\n\n//from vertex shader\nvarying highp vec3 world_pos;\nvarying highp vec3 world_normal;\nvarying highp vec4 world_color;\nvarying highp vec4 viewSpace;\n \nconst lowp vec3 fogColor = vec3(0.5, 0.5, 0.5);\nconst lowp float FogDensity = 0.5;\n \nvoid main() {\n    //vec3 tex1 = texture(texture1, texcoord).rgb;\n     \n    //get light an view directions\n    highp vec3 L = normalize( light_position - world_pos);\n    highp vec3 V = normalize( eye_position - world_pos);\n     \n    //diffuse lighting\n    highp vec3 diffuse = DiffuseLight;\n    if (useShading) {\n        diffuse = diffuse * (max(0., dot(L,world_normal)) + max(0., dot(vec3(-L.x, L.y, -L.z),world_normal)));\n    }\n     \n    //rim lighting\n    //highp float rim = float(1) - max(dot(V, world_normal), 0.0);\n    //rim = smoothstep(0.6, 1.0, rim);\n    //highp vec3 finalRim = RimColor * vec3(rim, rim, rim);\n    //get all lights and texture\n    //highp vec3 lightColor = (finalRim + diffuse) * world_color * 3.;\n    highp vec4 lightColor = vec4(diffuse,1) * world_color * vec4(3.,3.,3.,1.);\n     \n    //highp vec3 finalColor = vec3(0, 0, 0);\n     \n    //distance\n    //highp float dist = 0.;\n    //highp float fogFactor = 0.;\n\n    //range based\n    highp float dist = length(viewSpace);\n     \n    highp float fogFactor = 1.0/exp(dist * FogDensity);\n    fogFactor = clamp( fogFactor, 0.0, 1.0 );\n\n    //mix function fogColor*(1\u2212fogFactor) + lightColor*fogFactor\n    highp vec4 finalColor = mix(vec4(fogColor,world_color.a), lightColor, vec4(fogFactor));\n     \n    //show fogFactor depth(gray levels)\n    //fogFactor = 1 - fogFactor;\n    //out_color = vec4( fogFactor, fogFactor, fogFactor,1.0 );\n    gl_FragColor = finalColor;\n}");
e=a.createProgram();a.attachShader(e,b);a.attachShader(e,f);a.linkProgram(e);Object.keys(w).forEach(function(d){w[d]=d.startsWith("in_")?a.getAttribLocation(e,d):a.getUniformLocation(e,d)});a.blendFunc(770,771);a.enable(a.BLEND);x();requestAnimationFrame(D);p.a=Math.PI})();u=Function();p={x:0,y:0,z:0,b:0,a:0,c:0};
